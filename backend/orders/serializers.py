import secrets
import string
from rest_framework import serializers
from django.db import transaction
from .models import Order, OrderItem
from stores.models import Product

class OrderItemSerializer(serializers.ModelSerializer):
    product_id = serializers.IntegerField()

    class Meta:
        model = OrderItem
        fields = ['product_id', 'quantity', 'price']
        read_only_fields = ['price']

class OrderSerializer(serializers.ModelSerializer):
    items = OrderItemSerializer(many=True)
    store = serializers.PrimaryKeyRelatedField(read_only=True)
    total_amount = serializers.DecimalField(max_digits=10, decimal_places=2, read_only=True)
    
    # Read-only tracking fields (generated by backend)
    order_reference = serializers.CharField(read_only=True)
    tracking_token = serializers.CharField(read_only=True)
    buyer_name = serializers.CharField(required=False)
    buyer_phone = serializers.CharField(required=False)
    payment_method = serializers.ChoiceField(choices=['cod','chapa','telebirr','mpesa'], required=False)

    class Meta:
        model = Order
        fields = ['id', 'store', 'buyer_name', 'buyer_phone', 'total_amount', 'status', 'order_reference', 'tracking_token', 'items', 'payment_method']

    def generate_ref(self):
        """Generates a short code like SV-9A2B3C"""
        chars = string.ascii_uppercase + string.digits
        # 6 random chars
        code = ''.join(secrets.choice(chars) for _ in range(6))
        return f"SV-{code}"

    def create(self, validated_data):
        items_data = validated_data.pop('items')
        
        if not items_data:
            raise serializers.ValidationError("Order must have at least one item.")

        first_product_id = items_data[0]['product_id']
        try:
            first_product = Product.objects.get(id=first_product_id)
            store = first_product.store
        except Product.DoesNotExist:
            raise serializers.ValidationError("Product not found.")

        # Buyer Info Logic
        buyer_name_input = validated_data.pop('buyer_name', None)
        buyer_phone = validated_data.pop('buyer_phone', 'N/A')
        validated_data.pop('shipping_address', None) 

        request = self.context.get('request')
        if buyer_name_input:
            buyer_name = buyer_name_input
        elif request and request.user.is_authenticated:
            buyer_name = request.user.username
        else:
            buyer_name = "Guest"

        # Validate payment method against store configuration
        selected_method = validated_data.pop('payment_method', 'cod')
        if selected_method not in ['cod','chapa','telebirr','mpesa']:
            selected_method = 'cod'
        # Enforce store configuration: non-COD must be enabled by the store
        if selected_method != 'cod':
            enabled_methods = getattr(store, 'payment_methods', []) or []
            if selected_method not in enabled_methods:
                raise serializers.ValidationError({
                    'payment_method': 'Selected payment method is not enabled by this store.'
                })
            # Optional: ensure account detail exists
            accounts = getattr(store, 'payment_accounts', {}) or {}
            if not accounts.get(selected_method):
                raise serializers.ValidationError({
                    'payment_method': 'Store has no account information for the selected method.'
                })

        # ðŸŽ² Generate Unique Reference & Token
        ref = self.generate_ref()
        # Retry if collision (rare)
        while Order.objects.filter(order_reference=ref).exists():
            ref = self.generate_ref()
            
        token = secrets.token_urlsafe(32)

        with transaction.atomic():
            order = Order.objects.create(
                store=store,
                buyer_name=buyer_name,
                buyer_phone=buyer_phone,
                total_amount=0,
                payment_method=selected_method,
                order_reference=ref,   # ðŸ‘ˆ Save Ref
                tracking_token=token,  # ðŸ‘ˆ Save Token
                **validated_data
            )

            calculated_total = 0

            for item in items_data:
                try:
                    product = Product.objects.get(id=item['product_id'])
                except Product.DoesNotExist:
                    raise serializers.ValidationError(f"Product {item['product_id']} does not exist.")

                qty = item['quantity']
                if product.store != store:
                    raise serializers.ValidationError("All items must be from the same store.")
                if product.stock < qty:
                    raise serializers.ValidationError(f"Stock Error: Only {product.stock} units of '{product.name}' left.")

                product.stock -= qty
                product.save()

                line_total = product.price * qty
                calculated_total += line_total

                OrderItem.objects.create(
                    order=order,
                    product=product,
                    quantity=qty,
                    price=product.price
                )

            order.total_amount = calculated_total
            order.save()

        return order